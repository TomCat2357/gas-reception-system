# AppSheet JSON⇔シート変換 4層ヘッダー仕様書（拡張案 v1.0）

**対象**: Google AppSheet 互換の JSON データを、Google スプレッドシートの多段ヘッダー（4 層固定）にマッピング／ラウンドトリップ（JSON→シート→JSON）するための仕様。

---


## 1. 用語

- **DICT**: JSON オブジェクト（連想配列）。
- **LIST**: JSON 配列（本仕様では要素はプリミティブのみ。DICT は入らない）。
- **SCALAR**: 文字列／数値／真偽値などのプリミティブ。
- EXISTENSE\:DICTについて、そのキーが存在することを示すフラグが入る列の型。値としては何らかの文字が入るか入らないかの２択。普通は文字として１が入る。
- **ヘッダー層**: L1, L2, L3, L4 の 4 段固定。列は `L1→L2→L3→L4` の順のパスで一意に定義。
- **NULL**: パスが 4 段に満たない場合にヘッダーセルへ入れるプレースホルダ文字列（“NULL”）。

> 注: 既存実装は空文字でパディングしているが、本仕様では **視認性と往復変換の明示性** を優先して “NULL” を推奨。実装では置換可能な **HeaderNullToken** として持つ。

---

## 2. 設計思想（方針）

1. **列＝パス**: 列は 4 段のパス（L1..L4）で一意に決まる。セルは常に 1 値。パスは２行目から５行目にそれぞれ入る。１行目はその列の型（LIST,**SCALAR**,**EXISTENSE**)
2. **EXISTENSEは存在フラグ**: DICT のキーを列の値は 1を格納する。
3. **LIST は連結文字列**: LIST は単一セルに[A,B,C,...]で格納する。空配列 `[]` は[]。
4. **SCALAR はそのまま**: SCALARはセルにそのまま格納する。
5. **親ノードも列化**: 任意の階層で DICT に遭遇したら、当該ノード自身の列（残りは NULL）にも 1 を入れる（親の存在を明示）。たとえDICTの中に何か入っていたとしても実際の子DICTではなくて、1を入れる。たとえば{"A":{}}でも、{"A":{"B":"XXX"}}であったとしても、[A,NULL,NULL,NULL]:1となる。（後者はそれに加え[A,B,NULL,NULL]\:XXX)
6. **深さ制限**: 5 層目以降（>4）は **無視**。ただし 4 層目が DICT だった場合は、その列に 1 を入れて **切り上げ**る。
7. **NULL パディング**: パスが 4 段に満たない場合、残りのヘッダーは NULL で埋める。
8. **列順**: **L1→L2→L3→L4 の優先でソート**し、同一キー内は **JSON の出現順**（出現順が無ければ辞書順）。
9. **ヘッダー運用**: 既存ヘッダーがあればそれを尊重。必要に応じて新規列（パス）を追加する。

---

## 3. ヘッダー仕様

- ヘッダーは **1〜5 行目**。**1 行目**は列の型（`LIST`/`SCALAR`/`EXISTENSE`）、**2〜5 行目**に `[L1, L2, L3, L4]` を格納。足りない段は `NULL`。
- スタイル（罫線や色）は実装依存。本仕様では意味論のみを規定する。

### 3.1 ヘッダー生成（初回または拡張時）

- JSON から抽出した **列パス候補**（親 DICT ノードも含む／最大 4 段）をユニーク化し、**L1→L2→L3→L4 の優先でソート**し、同一キー内は **JSON の出現順**（出現順が無い場合のみ辞書順）で並べる。
- ヘッダー 4行（シート上では2～5 行目）に `[L1..L4]` をセット（不足は NULL）。

### 3.2 ヘッダー解釈（既存シート）

- 4 行分（シート上では2～5 行目）を読み、空白や NULL をパディングとして扱い、末尾の連続する NULL は落として **実パス**とする。

---

## 4. JSON → シート（書き込み）

### 4.1 アルゴリズム（概略）

1. ルートから DFS/BFS で走査。
2. 各ノードについて、現在の階層 `d` と値 `v` を評価：
   - `d ≤ 4` かつ `v` が **DICT**:
     - 列 `[L1..Ld, NULL..NULL]` に 1 を出力（親の存在を明示）。
     - 子要素について再帰。`d=4` の場合は子は **無視**。
   - `d ≤ 4` かつ `v` が **LIST**（要素は SCALAR 前提）:
     - 列 `[L1..Ld, NULL..NULL]` に **JSON 配列リテラル文字列**（例: `["a","b"]`）を出力。空配列は `[]`。
   - `d ≤ 4` かつ `v` が **SCALAR**:
     - 列 `[L1..Ld, NULL..NULL]` に値を出力。
   - `d > 4`: 無視（切り捨て）。

### 4.2 LIST の格納仕様

- セルには **JSON 配列リテラル文字列**をそのまま格納する。例: `["a","b",1,true]`。
- 空配列は `[]`。
- 文字列要素は JSON に従い二重引用符で囲む。内部の `"` や `\` は JSON 規則でエスケープ。
- カンマや区切りの独自定義は行わない（JSON として parse 可能であることを前提）。

### 4.3 親 1 の重複

- 親 1 と子列の値が同一ノードに共存するのは仕様どおり（親の存在＋子の中身）。

### 4.4 列の追加（拡張モード）

- 未知パスに遭遇した場合、列を追加してヘッダーを再描画。列順はL1>L2>L3>L4の優先順位とし、同一の場合は、JSONの出現順とする。そのためには、予めJSONの出現順をしらなくてはならいが、それは別機能で完全なJSONを出力することで実装する。

---

## 5. シート → JSON（読み込み）

### 5.1 型ヒントと推論

- 各列は 1 行目の型で **Kind** を明示する：`EXISTENSE`（DICT 存在フラグ）, `LIST`, `SCALAR`。
- **Kind の決定**（優先順）：
  1. **ヘッダー 1 行目**の型に従う。
  2. スキーマ定義がある場合は整合性チェックを行い、矛盾があればエラーまたは警告。
  3. 型未記入列のみ推論（同一パスの子列があれば `EXISTENSE`、`[]` 形式が見えれば `LIST`、それ以外は `SCALAR`）。

### 5.2 アルゴリズム（概略）

1. ヘッダーから全列のパス配列を得る。
2. 各セル値 `cell` をパスにしたがって JSON へ反映：
   - **EXISTENSE 列**: セルが**非空**であれば、対応ノードを `{}` で確保（値は常に「1」を推奨）。
   - **LIST 列**: セルが `[]` なら空配列。`[ ... ]` の場合は **JSON としてパース**して配列化。空白または未入力は未設定（キー自体を省略）。
   - **SCALAR 列**: セル値をそのまま代入（必要に応じて型推定／キャスト規約を適用）。
3. 親・子が同時に存在する場合：子の値はそのまま、親は `{}`（空でも可）。
4. 4 層を超える情報は復元しない。

### 5.3 空文字の扱い

- `scalar` 列の空文字は **未設定**として **省略**するのを既定とする（空文字自体を有効値にしたい場合は運用で型定義）。

---

## 6. 例（4 層）

### 入力 JSON（4 層 & 深さ超過あり）

```json
{
  "A": {
    "B": 123,
    "C": ["x","y"],
    "D": {
      "E": 1,
      "F": {},
      "G": { "H": 1, "I": {"J": 9} }
    }
  },
  "K": {},
  "L": []
}
```

### シートへの出力（列： [L1, L2, L3, L4] → 値）

```
[A, NULL, NULL, NULL] : 1      # A は DICT
[A, B,   NULL, NULL]  : 123       # SCALAR
[A, C,   NULL, NULL]  : ["x","y"]     # LIST を連結
[A, D,   NULL, NULL]  : 1      # D は DICT
[A, D, E,   NULL]     : 1         # SCALAR
[A, D, F,   NULL]     : 1      # 空オブジェクト
[A, D, G,   NULL]     : 1      # G は DICT（H や I は 5 層目なので切捨て）
[K, NULL, NULL, NULL] : 1      # 空オブジェクト
[L, NULL, NULL, NULL] : []        # 空配列
```

### 復元結果（シート→JSON）

```json
{
  "A": {
    "B": 123,
    "C": ["x","y"],
    "D": { "E": 1, "F": {}, "G": {} }
  },
  "K": {},
  "L": []
}
```

※ 5 層目（`G.H` と `G.I.*`）は仕様どおり復元されない。

---

## 7. 実装ガイド（GAS への適用）

### 7.1 推奨 API（擬似）

- `flattenToCells(json, { depth=4, headerNullToken='NULL', extendHeaders=true }) → { headerKinds, headerPaths, rowValues }`
- `unflattenFromCells(headerKinds, headerPaths, rowValues, { depth=4, headerNullToken='NULL' }) → json`

> 注: `headerKinds` は 1 行目（型行）の配列、`headerPaths` は 2〜5 行目のパス配列を表す。

### 7.2 既存ユーティリティの再利用 既存ユーティリティの再利用

- **ヘッダー I/O** … 4 段固定の読み書き、列ソート、パス正規化を流用。
- **列順** … 既存列は維持。**新規列の追加時**は **L1→L2→L3→L4 優先 + JSON 出現順**（無ければ辞書順）。

### 7.3 差分ポイント

1. **LIST の格納形式**: 区切り文字連結ではなく、**JSON 配列リテラル文字列**をセルに格納。
2. **親存在の表現**: DICT 遭遇時は、当該ノード列（残り NULL）へ **1** を必ず出力（以前の TRUE を置換）。
3. **型行（1 行目）の導入**: 各列の型を `LIST`/`SCALAR`/`EXISTENSE` で明示。読み戻しは型行を最優先。
4. **NULL パディング**: 2〜5 行目の不足ヘッダーは `NULL` で埋める（`HeaderNullToken` で変更可）。
5. **列順の統一**: ヘッダー生成・拡張とも **L1→L2→L3→L4 優先 + JSON 出現順**（無ければ辞書順）。

---

## 8. エッジケース／制約

- LIST 内に DICT は入れない（前提）。入った場合の動作は未定義。
- LIST 要素に区切り文字が含まれる場合は、エスケープまたは代替区切りを運用で保証。
- 空文字と `null`／`undefined` の区別は運用定義。既定は「空文字は未設定として省略」。
- 4 層超過は情報落ちが発生しうる。設計段階で許容の上で採用すること。

---

## 9. テスト観点

- JSON→シート→JSON の往復一致（深さ≦4 のみを比較）。
- DICT（空含む）／LIST（空含む）／SCALAR の各組み合わせ。
- 区切り文字含有時のエスケープケース。
- 親 TRUE と子値の共存ケース。
- 既存ヘッダーあり／なし、拡張モード ON/OFF の列追加挙動。

---

## 10. 既存環境との互換性

- 既存の「配列を添字展開」形式シートとは互換でないため、**モードフラグ**（例: `ARRAY_AS_CELL=true`）を導入して段階的移行を推奨。
- ヘッダーの空文字パディング→NULL 表示も切替可能とする（UI 仕様）。

---

## 付録 A: 列パスの規約

- `L1..L4` は文字列キー。
- 列内部キーは `L1 + '›' + L2 + '›' + L3 + '›' + L4` のような連結（実装依存）。
- 列順は **L1→L2→L3→L4 優先 + JSON 出現順**（出現順が無ければ辞書順）。

---

以上。

